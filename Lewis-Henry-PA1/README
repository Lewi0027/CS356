# PA1 README
Block and Stream cipher program

## Generated executable should be named 'cipher'

## Program will take FIVE arguments:
1. Cipher Type
2. Input File Path
3. Output File Path
4. Key File Path
5. Mode of Operation
### Ensure there are exactly 5 arguments!

## Each argument should be validated:
### Cipher Type
* Value will be either 'B' or 'S'.
* B means you will use your Block cipher.
* S means you will use your Stream cipher.
* Error Checking: Your program should terminate graciously if anything other than a 'B' or an 'S' is given as an argument. The exit status of your program should be 1, indicating that your program encountered an invalid argument. The error message generated by your program should be - "Invalid Function Type".

### Input File Path
* The plaintext file will be in ASCII format.
* Error Checking: Your program should terminate graciously (with exit status 1) with an appropriate error message if the input file does not exist. The error message generated by your program should be - "Input File Does Not Exist".

### Output File Path
* The specified output file should be created by your program and your program should write the encrypted ciphertext or decrypted plaintext to the specified output file.

### Key File Path
* The key file contains the symmetric key in AASCII format (e.g.: "COMPUTER76543210").
* The key size for Block Cipher would be 16 bytes. Each character in the key file is considered 1 byte. So, the key file will contain 16 characters for the block cipher.
* The keysize for Stream Cipher can be of any length.
* Your program should read in the contents of the key file and use it to encrypt the provided plaintext or decrypt the provided ciphertext.
* The key file will not contain a terminating "\n" (newline) character.
* Error Checking: Your program should terminate graciously (with exit status 1) with an appropriate error message if the key file does not exist. The error message generated by your program should be - "Key File Does Not Exist".

### Mode of Operation
* It can either be 'E' for encryption or 'D' for decryption.
* You can use the same encryption or decryption module for stream cipher. But it does not apply for block cipher.
* In the encryption mode, you will encrypt a plaintext using the key found in the key file and produce a ciphertext. Your ciphertext output will be evaluated against the output produced by the TAs' program with the same key.
* Similarly, in the decryption mode, your program is expected to decrypt a ciphertext, with the key found in the key file, and produce a plaintext, which will also be evaluated against the output produced by the TAs' program with the same key.
* Error Checking: Your program should terminate graciously if anything other than a 'E' or an 'D' is given as an argument. The exit status of your program should be 1, indicating that your program encountered an invalid argument. The error message generated by your program should be - "Invalid Mode Type".

## Other Requirements
* Besides the error messages described above for error checking the arguments, do not print anything to the console. 
* The encrypted ciphertext or the decrypted plaintext generated by your program should be written only to the output file.
* If you are using C++, do not throw an exception (like std::invalid_argument) without catching it.
* The end of line (EOL) or newline character should be treated and processed just like any other character. If the input file contains newlines, your program should preserve the newlines in the same order throughout the encryption and/or decryption process.
* If the input file is empty, the output file should be empty. Your program should generate an empty output file even if the input file is empty. Do not print anything to the console.
* The following are examples of how your program might be executed from the command line:
  1. ./cipher B b-e-input.txt b-e-output.txt b-e-key.txt E
  2. ./cipher S s-d-input.txt s-d-output.txt s-d-key.txt D

## Algorithms:
### Block Cipher
1. Encryption is a 3 step process:
  * Pad (if neceessary)
  * Encrypt (using XOR)
  * Swap
2. Block size WILL be 16 bytes.
  * Can read in one of two ways:
    * Read the whole input string from the input file, store it in a data structure (string or vector for C++ and char array for C), and then take 16-byte substring as blocks until you read the whole string.
    * Directly read in 16-byte blocks as chunks from the input file at a time until you reach the end of the file.
  * If a block is found to be less than 16 bytes, it should be padded with as many padding bytes as required to make it 16 bytes. Use 0x81 as the padding byte.
3. Your algorithm will XOR the 16-byte data block with the 16-byte key (from the key file) in a bytewise manner.
  * Each byte of the 16-byte key starting from the leftmost byte (index 0) will be XORed with each byte of a 16-byte data block, starting from the left-hand side (index 0).
4. Your algorithm will then swap bytes for each XORed output (16-byte block).
  * Let 'start' and 'end' be pointers that point to the start and end of the XORed output block.
  * For each byte of the key, starting from the leftmost byte or index 0, you should calculate:
    * (ASCII value of the byte or character) % 2. (Either 0 or 1)
  * If the value is 0:
    * Do not swap anything and move on to the next byte of the block by incrementing the 'start' pointer.
  * If the value is 1:
    * Swap the byte position pointed to by the 'start' pointer with the byte position pointed to by the 'end' pointer. Then, increment the 'start' pointer so that it points to the next higher byte position and decrement the 'end' pointer so that it points to the next lower byte position.
    * If the key size is exhausted, restart from the first byte of the key (index 0). This process is carried on until the 'start' and the 'end' pointers collide. The swap process then stops and produces the required encrypted output.
5. The decryption process is also of three steps but proceeds in the reverse order as the encryption process:
  * Decryption process:
    * Swap
    * Decrypt (using XOR)
    * Remove padding (if required)
  * Because the decryption process occurs in the reverse direction of the encryption process, you cannot use the same module to perform both, although the underlying logic will be the same.

### Stream Cipher
1. You will XOR the input stream with the key in the following manner:
  * The key will be give in ASCII (e.g. "TheKeySizeForStreamCipherMayBeLongerThan16Bytes").
  * You will XOR the bytes or characters from the input file with the bytes or the characters from the key file, starting from the leftmost byte or index 0 for both.
  * Byte 0 from the input file will be XORed with byte 0 from the key
  * Byte 1 from the input file will be XORed with Bit 1 from the key
  * ...
  * Byte n - 1 from the input file will be XORed with Byte n - 1 from the key
2. If you reach the end of the key, start over from the beginning (from index 0).
3. Encryption and decryption will be performed with the same module that you design for the stream cipher. In other words, you do not have to design separate modules for encryption and decryption in the stream cipher type.